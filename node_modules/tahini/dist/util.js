'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.rejectify = exports.toJS = exports.getNextState = exports.addRelativePath = exports.applyPartialAction = exports.isolateMutationByDataPath = exports.consumeActionByNamespace = undefined;

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _immutable = require('immutable');

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function _objectWithoutProperties(obj, keys) { var target = {}; for (var i in obj) { if (keys.indexOf(i) >= 0) continue; if (!Object.prototype.hasOwnProperty.call(obj, i)) continue; target[i] = obj[i]; } return target; }

// consume the namespace from the action on dispatch
// this explains how to turn a reducerHash into a reducer
var consumeActionByNamespace = function consumeActionByNamespace(reducerHash) {
  return function (state, _ref) {
    var _ref$namespace = _ref.namespace,
        namespace = _ref$namespace === undefined ? 'global' : _ref$namespace,
        action = _objectWithoutProperties(_ref, ['namespace']);

    return reducerHash[namespace][action.type](state, action);
  };
};

// consume the dataPath, scope the mutation to the mount point
exports.consumeActionByNamespace = consumeActionByNamespace;
var isolateMutationByDataPath = function isolateMutationByDataPath(reducer) {
  return function () {
    var state = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : (0, _immutable.fromJS)({});
    var _ref2 = arguments[1];

    var _ref2$dataPath = _ref2.dataPath,
        dataPath = _ref2$dataPath === undefined ? [] : _ref2$dataPath,
        action = _objectWithoutProperties(_ref2, ['dataPath']);

    return state.setIn(dataPath, reducer(state.getIn(dataPath), action));
  };
};

exports.isolateMutationByDataPath = isolateMutationByDataPath;
var applyPartialAction = exports.applyPartialAction = function applyPartialAction(partial) {
  return function (actions) {
    return Object.keys(actions).reduce(function (p, c) {
      return _extends({}, p, _defineProperty({}, c, function () {
        return _extends({}, actions[c].apply(actions, arguments), partial);
      }));
    }, {});
  };
};

var addRelativePath = exports.addRelativePath = function addRelativePath(dataPath, relPath) {
  var fullPath = [].concat(dataPath);
  relPath.forEach(function (part) {
    return part === '..' ? fullPath.pop() : fullPath.push(part);
  });
  return fullPath;
};

// testing util
var getNextState = exports.getNextState = function getNextState(store) {
  var fn = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : function () {
    return 0;
  };
  return function () {
    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    return new Promise(function (s, j) {
      var f = store.subscribe(function () {
        f();
        s(store.getState());
      });

      fn.apply(undefined, args);
    });
  };
};

var toJS = exports.toJS = function toJS(state) {
  return state.toJS();
};

var rejectify = exports.rejectify = function rejectify(fn) {
  return function (state) {
    try {
      fn(state);
      return Promise.resolve();
    } catch (e) {
      return Promise.reject(e);
    }
  };
};