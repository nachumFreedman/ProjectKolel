'use strict';

var _ = require('./');

var _2 = _interopRequireDefault(_);

var _chai = require('chai');

var _chai2 = _interopRequireDefault(_chai);

var _sinon = require('sinon');

var _sinon2 = _interopRequireDefault(_sinon);

var _sinonChai = require('sinon-chai');

var _sinonChai2 = _interopRequireDefault(_sinonChai);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

_chai2.default.use(_sinonChai2.default);

describe('polling handler', function () {
  it('starts polling, etc', function (doneTest) {

    var next = _sinon2.default.spy();
    var done = _sinon2.default.spy();
    var err = _sinon2.default.spy();

    var testValue = 'whatever';
    var testUrl = 'some.thing';
    var testResponse = function testResponse() {
      return Promise.resolve(testValue);
    };
    global.fetch = _sinon2.default.stub().returns(new Promise(function (resolve, rej) {
      setTimeout(function () {
        resolve({
          status: 200,
          json: testResponse
        });
      }, 50);
    }));
    var poll = new _2.default(next, done, err);

    // spy on listWala.poll.handleRequest

    var action = {
      network: {
        handler: 'Poller',
        url: testUrl,
        interval: 10, // ms
        headers: { a: 'b' }
      },
      nextAction: {}
    };

    var unsub = poll.handleRequest(action);

    // should test just that the requests are made
    // don't need to test that the headers get set and whatnot.

    setTimeout(function () {
      (0, _chai.expect)(fetch).to.have.been.calledWith(testUrl);
      (0, _chai.expect)(fetch.firstCall.args[1].method).to.eql('GET');
      (0, _chai.expect)(fetch.firstCall.args[1].headers instanceof Headers).to.be.ok;
      (0, _chai.expect)(fetch.firstCall.args[1].headers.a).to.eql('b');

      (0, _chai.expect)(next.firstCall.args[0]).to.eql(testValue);

      (0, _chai.expect)(next).to.be.called; // timing prohibits counting accurately
      (0, _chai.expect)(err).to.be.not.called;

      (0, _chai.expect)(done).to.not.have.been.calledOnce;
      unsub();
      (0, _chai.expect)(done).to.have.been.calledOnce;

      doneTest();
    }, 100);
  });

  it('send back errors properly', function (doneTest) {

    var next = _sinon2.default.spy();
    var done = _sinon2.default.spy();
    var err = _sinon2.default.spy();

    var testValue = 'whatever';
    var testUrl = 'some.thing';
    var testStatus = 400;
    var testResponse = function testResponse() {
      return Promise.resolve(testValue);
    };
    global.fetch = _sinon2.default.stub().returns(new Promise(function (resolve, rej) {
      setTimeout(function () {
        resolve({
          status: testStatus,
          json: testResponse
        });
      }, 50);
    }));
    var poll = new _2.default(next, done, err);

    // spy on listWala.poll.handleRequest

    var action = {
      network: {
        handler: 'Poller',
        url: testUrl,
        interval: 10, // ms
        headers: { a: 'b' }
      },
      nextAction: {}
    };

    var unsub = poll.handleRequest(action);

    setTimeout(function () {
      (0, _chai.expect)(fetch).to.have.been.calledWith(testUrl);
      (0, _chai.expect)(fetch.firstCall.args[1].method).to.eql('GET');
      (0, _chai.expect)(fetch.firstCall.args[1].headers instanceof Headers).to.be.ok;
      (0, _chai.expect)(fetch.firstCall.args[1].headers.a).to.eql('b');

      (0, _chai.expect)(err.firstCall.args[0].body).to.eql(testValue);
      (0, _chai.expect)(err.firstCall.args[0].status).to.eql(testStatus);

      (0, _chai.expect)(next).to.not.be.called;
      (0, _chai.expect)(err).to.be.called;

      (0, _chai.expect)(done).to.not.have.been.calledOnce;
      unsub();
      (0, _chai.expect)(done).to.have.been.calledOnce;

      doneTest();
    }, 100);
  });
});

// also should test preunsub, calling handleRequest twice, changing the action midstream