'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _networkHandlers = require('./network-handlers/');

var _networkHandlers2 = _interopRequireDefault(_networkHandlers);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _objectWithoutProperties(obj, keys) { var target = {}; for (var i in obj) { if (keys.indexOf(i) >= 0) continue; if (!Object.prototype.hasOwnProperty.call(obj, i)) continue; target[i] = obj[i]; } return target; } // the nextAction pattern should be refactored out of this network middleware

// any actionHandler who returns a promise can do a nextAction

// networkHandlers are more like observables
// so they should have an responseAction
// which gets triggered on any response in a stream

// either way though, the asynchronous behaviour is managed in middleware
// where the action instruction structure is managed entirely in the actioncreator.


// actions should be able to name the handler instance they wish to route to
// in order that downstream triggered actions can be collected through the same handler


// intercept actions with a network field on them
// call the network handler and then dispatch a new action in the right lexical scope

// this needs a test for chained network actions

exports.default = function (Handlers) {
  var activeHandlers = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
  return function (store) {
    return function (next) {
      return function (action) {
        var _action$network = action.network,
            network = _action$network === undefined ? {} : _action$network,
            type = action.type,
            payload = action.payload,
            lexicalScope = _objectWithoutProperties(action, ['network', 'type', 'payload']);

        var nextAction = network.nextAction,
            doneAction = network.doneAction,
            errAction = network.errAction,
            handler = network.handler;


        if (handler) {
          if (!(handler in Handlers)) throw handler + ' not found. Check that it has been declared and imported';

          var dath = JSON.stringify(lexicalScope.dataPath);

          // resolve a request handler

          if (!(lexicalScope.namespace in activeHandlers)) {
            activeHandlers[lexicalScope.namespace] = {};
          }

          if (!(dath in activeHandlers[lexicalScope.namespace])) {
            activeHandlers[lexicalScope.namespace][dath] = {};
          }

          if (!(network.handler in activeHandlers[lexicalScope.namespace][dath])) {

            activeHandlers[lexicalScope.namespace][dath][handler] = new Handlers[handler](function (response) {
              store.dispatch(_extends({}, lexicalScope, response, nextAction));
            }, function () {
              if (doneAction) store.dispatch(_extends({}, lexicalScope, doneAction));
              delete activeHandlers[lexicalScope.namespace][JSON.stringify(lexicalScope.dataPath)];
            }, function (err) {
              if (errAction) store.dispatch(_extends({}, lexicalScope, err, errAction));
            }, _networkHandlers2.default);
          }

          // find one that is for this provider
          // or instantiate a new one

          // using lexicalScope.namespace, datapath, 

          var activeHandler = activeHandlers[lexicalScope.namespace][dath][handler];

          // test and discuss
          if (type) {
            store.dispatch(_extends({ type: type, payload: payload }, lexicalScope));
          }

          // call its handleRequest method
          return activeHandler.handleRequest(action); // w payload
        } else {
          return next(action);
        }
      };
    };
  };
};